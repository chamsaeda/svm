<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SVM ì•Œê³ ë¦¬ì¦˜</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { 
      font-family: 'Malgun Gothic', sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
    }
    canvas { image-rendering: auto; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const SVMDemo = () => {
      const canvasRef = useRef(null);
      const WIDTH = 600;
      const HEIGHT = 500;
      const PADDING = 50;

      const generateInitialData = () => {
        const initialPoints = [];
        for (let i = 0; i < 8; i++) {
          initialPoints.push({
            x: PADDING + 50 + Math.random() * 150,
            y: PADDING + 50 + Math.random() * 150,
            class: 1
          });
        }
        for (let i = 0; i < 8; i++) {
          initialPoints.push({
            x: WIDTH - PADDING - 200 + Math.random() * 150,
            y: HEIGHT - PADDING - 200 + Math.random() * 150,
            class: -1
          });
        }
        return initialPoints;
      };

      const [showSVTooltip, setShowSVTooltip] = useState(false);
      const [points, setPoints] = useState(generateInitialData());
      const [selectedClass, setSelectedClass] = useState(1);
      const [kernelMode, setKernelMode] = useState('linear');
      const [polynomialDegree, setPolynomialDegree] = useState(2);
      const [rbfGamma, setRbfGamma] = useState(0.5);
      const [sigmoidAlpha, setSigmoidAlpha] = useState(0.01);
      const [sigmoidC0, setSigmoidC0] = useState(0);
      const [costC, setCostC] = useState(1.0);
      const [svm, setSvm] = useState(null);
      const [hovered, setHovered] = useState(null);

      const trainLinearSVM = useCallback(() => {
        if (points.length < 2) return null;
        const class1Points = points.filter(p => p.class === 1);
        const class2Points = points.filter(p => p.class === -1);
        if (class1Points.length === 0 || class2Points.length === 0) return null;

        let bestMargin = -Infinity;
        let bestParams = null;

        for (let angle = 0; angle < 180; angle += 2) {
          const rad = (angle * Math.PI) / 180;
          const a = Math.cos(rad);
          const b = Math.sin(rad);
          const projections = points.map(p => ({
            value: a * p.x + b * p.y,
            class: p.class,
            point: p
          }));

          const proj1 = projections.filter(p => p.class === 1);
          const proj2 = projections.filter(p => p.class === -1);
          const max1 = Math.max(...proj1.map(p => p.value));
          const min1 = Math.min(...proj1.map(p => p.value));
          const max2 = Math.max(...proj2.map(p => p.value));
          const min2 = Math.min(...proj2.map(p => p.value));

          if (max1 < min2 || max2 < min1) {
            const boundary = (Math.max(min1, min2) + Math.min(max1, max2)) / 2;
            const c = -boundary;
            const margin = Math.min(Math.abs(boundary - max1), Math.abs(boundary - min2));

            if (margin > bestMargin) {
              bestMargin = margin;
              bestParams = { a, b, c, margin, boundary };
            }
          }
        }

        if (!bestParams) {
          const center1 = {
            x: class1Points.reduce((sum, p) => sum + p.x, 0) / class1Points.length,
            y: class1Points.reduce((sum, p) => sum + p.y, 0) / class1Points.length
          };
          const center2 = {
            x: class2Points.reduce((sum, p) => sum + p.x, 0) / class2Points.length,
            y: class2Points.reduce((sum, p) => sum + p.y, 0) / class2Points.length
          };
          const midX = (center1.x + center2.x) / 2;
          const midY = (center1.y + center2.y) / 2;
          const dx = center1.x - center2.x;
          const dy = center1.y - center2.y;
          const norm = Math.sqrt(dx * dx + dy * dy);
          const a = dy / norm;
          const b = -dx / norm;
          const c = -(a * midX + b * midY);
          
          const minDist = Math.min(
            ...points.map(p => Math.abs(a * p.x + b * p.y + c))
          );
          
          bestParams = { a, b, c, margin: minDist, boundary: 0 };
        }

        if (bestParams) {
          const { a, b, c } = bestParams;
          
          // Costì— ë”°ë¥¸ ë§ˆì§„ ì¡°ì •: ë†’ì€ C = ì¢ì€ ë§ˆì§„, ë‚®ì€ C = ë„“ì€ ë§ˆì§„
          const marginWidth = bestParams.margin * Math.max(0.3, 3 / costC);
          
          // ê²½ê³„ì„ ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ ê³„ì‚°í•˜ì—¬ ì„œí¬íŠ¸ ë²¡í„° ì„ íƒ
          const distances = points.map(p => ({
            point: p,
            dist: Math.abs(a * p.x + b * p.y + c),
            signedDist: (a * p.x + b * p.y + c) * p.class
          }));
          
          // ë§ˆì§„ ë‚´ë¶€ì— ìˆê±°ë‚˜ ê²½ê³„ì— ê°€ê¹Œìš´ ì ë“¤ì„ ì„œí¬íŠ¸ ë²¡í„°ë¡œ ì„ íƒ
          const supportVectors = [];
          const threshold = marginWidth * 1.1; // ë§ˆì§„ë³´ë‹¤ ì•½ê°„ ì—¬ìœ ìˆê²Œ
          
          distances.forEach(d => {
            // ê²½ê³„ì„ ì— ê°€ê¹Œìš´ ì ë“¤ (ë§ˆì§„ ë‚´ë¶€ ë˜ëŠ” ê²½ê³„ ê·¼ì²˜)
            if (d.dist <= threshold) {
              supportVectors.push(d.point);
            }
          });
          
          // ì„œí¬íŠ¸ ë²¡í„°ê°€ ë„ˆë¬´ ì ìœ¼ë©´ ê°€ì¥ ê°€ê¹Œìš´ ì ë“¤ ì¶”ê°€
          if (supportVectors.length < 2) {
            const sorted = [...distances].sort((a, b) => a.dist - b.dist);
            const numToAdd = Math.max(2, Math.min(6, Math.ceil(8 / costC)));
            for (let i = 0; i < numToAdd && i < sorted.length; i++) {
              if (!supportVectors.includes(sorted[i].point)) {
                supportVectors.push(sorted[i].point);
              }
            }
          }
          
          bestParams.supportVectors = supportVectors;
          bestParams.adjustedMargin = marginWidth;
        }

        return bestParams;
      }, [points, costC]);

      const trainPolynomialSVM = useCallback(() => {
        if (points.length < 2) return null;
        const class1Points = points.filter(p => p.class === 1);
        const class2Points = points.filter(p => p.class === -1);
        if (class1Points.length === 0 || class2Points.length === 0) return null;

        const allX = points.map(p => p.x);
        const allY = points.map(p => p.y);
        const centerX = (Math.max(...allX) + Math.min(...allX)) / 2;
        const centerY = (Math.max(...allY) + Math.min(...allY)) / 2;
        const rangeX = Math.max(...allX) - Math.min(...allX);
        const rangeY = Math.max(...allY) - Math.min(...allY);
        const scale = Math.max(rangeX, rangeY) / 2 + 50;

        const transformPoint = (p, degree) => {
          const nx = (p.x - centerX) / scale;
          const ny = (p.y - centerY) / scale;
          const features = [1, nx, ny];
          if (degree >= 2) features.push(nx * nx, nx * ny, ny * ny);
          if (degree >= 3) features.push(nx * nx * nx, nx * nx * ny, nx * ny * ny, ny * ny * ny);
          return features;
        };

        const transformedData = points.map(p => ({
          features: transformPoint(p, polynomialDegree),
          class: p.class,
          original: p
        }));

        let weights = Array(transformedData[0].features.length).fill(0);
        const learningRate = 0.01 * costC;
        const maxEpochs = 500;
        
        for (let epoch = 0; epoch < maxEpochs; epoch++) {
          let errors = 0;
          let totalLoss = 0;
          
          transformedData.forEach(d => {
            const score = weights.reduce((sum, w, i) => sum + w * d.features[i], 0);
            const margin = d.class * score;
            
            if (margin < 1) {
              errors++;
              totalLoss += (1 - margin);
              for (let i = 0; i < weights.length; i++) {
                weights[i] += learningRate * (d.class * d.features[i] - 0.01 * weights[i] / costC);
              }
            } else {
              for (let i = 0; i < weights.length; i++) {
                weights[i] -= learningRate * 0.01 * weights[i] / costC;
              }
            }
          });
          
          if (errors === 0 && epoch > 50) break;
          if (totalLoss < 0.01) break;
        }

        const supportVectors = [];
        const threshold = Math.max(0.3, 2.0 / (1 + costC * 0.3));
        transformedData.forEach(d => {
          const value = weights.reduce((sum, w, i) => sum + w * d.features[i], 0);
          const margin = Math.abs(d.class * value);
          if (margin < threshold) supportVectors.push(d.original);
        });

        if (supportVectors.length === 0) {
          const margins = transformedData.map(d => ({
            margin: Math.abs(d.class * weights.reduce((sum, w, i) => sum + w * d.features[i], 0)),
            original: d.original
          })).sort((a, b) => a.margin - b.margin);
          
          const class1SVs = margins.filter(m => m.original.class === 1).slice(0, Math.max(1, Math.floor(margins.length * 0.1)));
          const class2SVs = margins.filter(m => m.original.class === -1).slice(0, Math.max(1, Math.floor(margins.length * 0.1)));
          supportVectors.push(...class1SVs.map(m => m.original), ...class2SVs.map(m => m.original));
        }

        return { weights, supportVectors, degree: polynomialDegree, centerX, centerY, scale };
      }, [points, polynomialDegree, costC]);

      const trainRBFSVM = useCallback(() => {
        if (points.length < 2) return null;
        const class1Points = points.filter(p => p.class === 1);
        const class2Points = points.filter(p => p.class === -1);
        if (class1Points.length === 0 || class2Points.length === 0) return null;
        
        const supportVectors = [];
        const threshold = Math.max(0.3, 1.5 / (1 + costC * 0.2));
        
        points.forEach(point => {
          const oppositePoints = points.filter(p => p.class !== point.class);
          const minDist = Math.min(...oppositePoints.map(p => 
            Math.sqrt(Math.pow(point.x - p.x, 2) + Math.pow(point.y - p.y, 2))
          ));
          
          if (minDist < 200 / costC) {
            supportVectors.push(point);
          }
        });
        
        if (supportVectors.length === 0) {
          const class1Closest = class1Points.sort((a, b) => {
            const aDist = Math.min(...class2Points.map(p => Math.hypot(a.x - p.x, a.y - p.y)));
            const bDist = Math.min(...class2Points.map(p => Math.hypot(b.x - p.x, b.y - p.y)));
            return aDist - bDist;
          }).slice(0, 2);
          
          const class2Closest = class2Points.sort((a, b) => {
            const aDist = Math.min(...class1Points.map(p => Math.hypot(a.x - p.x, a.y - p.y)));
            const bDist = Math.min(...class1Points.map(p => Math.hypot(b.x - p.x, b.y - p.y)));
            return aDist - bDist;
          }).slice(0, 2);
          
          supportVectors.push(...class1Closest, ...class2Closest);
        }
        
        return { points: [...points], gamma: rbfGamma, supportVectors };
      }, [points, rbfGamma, costC]);

      const trainSigmoidSVM = useCallback(() => {
        if (points.length < 2) return null;
        const class1Points = points.filter(p => p.class === 1);
        const class2Points = points.filter(p => p.class === -1);
        if (class1Points.length === 0 || class2Points.length === 0) return null;

        const allX = points.map(p => p.x);
        const allY = points.map(p => p.y);
        const centerX = (Math.max(...allX) + Math.min(...allX)) / 2;
        const centerY = (Math.max(...allY) + Math.min(...allY)) / 2;
        const scale = Math.max(
          Math.max(...allX) - Math.min(...allX),
          Math.max(...allY) - Math.min(...allY)
        ) / 2 + 10;

        const normalizedPoints = points.map(p => ({
          x: (p.x - centerX) / scale,
          y: (p.y - centerY) / scale,
          class: p.class,
          original: p
        }));

        const numHidden = Math.min(8, points.length);
        const hiddenCenters = [];
        const step = Math.max(1, Math.floor(normalizedPoints.length / numHidden));
        for (let i = 0; i < numHidden; i++) {
          const idx = (i * step) % normalizedPoints.length;
          hiddenCenters.push({
            x: normalizedPoints[idx].x,
            y: normalizedPoints[idx].y
          });
        }
        
        const hiddenWeights = hiddenCenters.map(() => (Math.random() - 0.5) * 0.1);
        let bias = 0;
        const learningRate = 0.1 * Math.sqrt(costC);
        
        for (let epoch = 0; epoch < 800; epoch++) {
          let totalError = 0;
          
          normalizedPoints.forEach(p => {
            let score = bias;
            hiddenCenters.forEach((center, i) => {
              const dx = p.x - center.x;
              const dy = p.y - center.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const activation = Math.tanh(sigmoidAlpha * (5 - dist * 10) + sigmoidC0);
              score += hiddenWeights[i] * activation;
            });
            
            const margin = p.class * score;
            
            if (margin < 1) {
              totalError += (1 - margin);
              hiddenCenters.forEach((center, i) => {
                const dx = p.x - center.x;
                const dy = p.y - center.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const activation = Math.tanh(sigmoidAlpha * (5 - dist * 10) + sigmoidC0);
                hiddenWeights[i] += learningRate * p.class * activation;
              });
              bias += learningRate * p.class * 0.1;
            }
            
            hiddenWeights.forEach((w, i) => {
              hiddenWeights[i] *= (1 - 0.001 / costC);
            });
          });
          
          if (totalError < 0.1 && epoch > 200) break;
        }

        const supportVectors = [];
        const threshold = Math.max(0.5, 2.0 / (1 + costC * 0.3));
        
        normalizedPoints.forEach(p => {
          let score = bias;
          hiddenCenters.forEach((center, i) => {
            const dx = p.x - center.x;
            const dy = p.y - center.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const activation = Math.tanh(sigmoidAlpha * (5 - dist * 10) + sigmoidC0);
            score += hiddenWeights[i] * activation;
          });
          
          const margin = Math.abs(p.class * score);
          if (margin < threshold) {
            supportVectors.push(p.original);
          }
        });

        if (supportVectors.length === 0) {
          const margins = normalizedPoints.map(p => {
            let score = bias;
            hiddenCenters.forEach((center, i) => {
              const dx = p.x - center.x;
              const dy = p.y - center.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const activation = Math.tanh(sigmoidAlpha * (5 - dist * 10) + sigmoidC0);
              score += hiddenWeights[i] * activation;
            });
            return {
              margin: Math.abs(p.class * score),
              original: p.original
            };
          }).sort((a, b) => a.margin - b.margin);
          
          const numSV = Math.max(2, Math.min(6, Math.ceil(points.length * 0.3 / costC)));
          supportVectors.push(...margins.slice(0, numSV).map(m => m.original));
        }

        return {
          hiddenCenters,
          hiddenWeights,
          bias,
          alpha: sigmoidAlpha,
          c0: sigmoidC0,
          centerX, centerY, scale,
          supportVectors
        };
      }, [points, sigmoidAlpha, sigmoidC0, costC]);

      const handleTrain = useCallback(() => {
        if (kernelMode === 'linear') {
          const result = trainLinearSVM();
          setSvm(result ? { ...result, type: 'linear' } : null);
        } else if (kernelMode === 'polynomial') {
          const result = trainPolynomialSVM();
          setSvm(result ? { ...result, type: 'polynomial' } : null);
        } else if (kernelMode === 'rbf') {
          const result = trainRBFSVM();
          setSvm(result ? { ...result, type: 'rbf' } : null);
        } else if (kernelMode === 'sigmoid') {
          const result = trainSigmoidSVM();
          setSvm(result ? { ...result, type: 'sigmoid' } : null);
        }
      }, [kernelMode, trainLinearSVM, trainPolynomialSVM, trainRBFSVM, trainSigmoidSVM]);

      useEffect(() => {
        if (svm && points.length >= 2) handleTrain();
      }, [costC]);

      useEffect(() => {
        if (svm && points.length >= 2 && kernelMode === 'rbf') handleTrain();
      }, [rbfGamma]);

      useEffect(() => {
        if (svm && points.length >= 2 && kernelMode === 'polynomial') handleTrain();
      }, [polynomialDegree]);

      useEffect(() => {
        if (svm && points.length >= 2 && kernelMode === 'sigmoid') handleTrain();
      }, [sigmoidAlpha, sigmoidC0]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        ctx.strokeStyle = '#e0e7ff';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
          const x = PADDING + (WIDTH - 2 * PADDING) * i / 10;
          const y = PADDING + (HEIGHT - 2 * PADDING) * i / 10;
          ctx.beginPath();
          ctx.moveTo(x, PADDING);
          ctx.lineTo(x, HEIGHT - PADDING);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(PADDING, y);
          ctx.lineTo(WIDTH - PADDING, y);
          ctx.stroke();
        }

        if (svm) {
          if (svm.type === 'linear') {
            const { a, b, c, adjustedMargin } = svm;
            const margin = adjustedMargin || svm.margin;
            
            const drawLine = (offset, style, width, dash = []) => {
              ctx.strokeStyle = style;
              ctx.lineWidth = width;
              ctx.setLineDash(dash);
              ctx.beginPath();
              if (Math.abs(b) < 0.01) {
                const x = -(c + offset) / a;
                ctx.moveTo(x, PADDING);
                ctx.lineTo(x, HEIGHT - PADDING);
              } else {
                const x1 = PADDING;
                const y1 = -(a * x1 + c + offset) / b;
                const x2 = WIDTH - PADDING;
                const y2 = -(a * x2 + c + offset) / b;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
              }
              ctx.stroke();
            };
            
            drawLine(0, '#16a34a', 3);
            drawLine(-margin, '#93c5fd', 2, [5, 5]);
            drawLine(margin, '#93c5fd', 2, [5, 5]);
            ctx.setLineDash([]);
          } else if (svm.type === 'polynomial') {
            const { weights, degree, centerX, centerY, scale } = svm;
            const predict = (x, y) => {
              const nx = (x - centerX) / scale;
              const ny = (y - centerY) / scale;
              const features = [1, nx, ny];
              if (degree >= 2) features.push(nx * nx, nx * ny, ny * ny);
              if (degree >= 3) features.push(nx * nx * nx, nx * nx * ny, nx * ny * ny, ny * ny * ny);
              return weights.reduce((sum, w, i) => sum + w * features[i], 0);
            };

            for (let x = PADDING; x < WIDTH - PADDING; x += 5) {
              for (let y = PADDING; y < HEIGHT - PADDING; y += 5) {
                ctx.fillStyle = predict(x, y) > 0 ? 'rgba(239, 68, 68, 0.1)' : 'rgba(59, 130, 246, 0.1)';
                ctx.fillRect(x, y, 5, 5);
              }
            }

            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 3;
            for (let x = PADDING; x < WIDTH - PADDING - 4; x += 4) {
              for (let y = PADDING; y < HEIGHT - PADDING - 4; y += 4) {
                const v = [predict(x, y), predict(x + 4, y), predict(x + 4, y + 4), predict(x, y + 4)];
                const s = v.map(val => val >= 0 ? 1 : 0);
                const cfg = s[0] * 8 + s[1] * 4 + s[2] * 2 + s[3];
                if (cfg !== 0 && cfg !== 15) {
                  ctx.beginPath();
                  if (cfg === 1 || cfg === 14) {
                    ctx.moveTo(x + 4 * Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[1])), y);
                    ctx.lineTo(x, y + 4 * Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3])));
                  } else if (cfg === 3 || cfg === 12) {
                    ctx.moveTo(x, y + 4 * Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3])));
                    ctx.lineTo(x + 4, y + 4 * Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[2])));
                  }
                  ctx.stroke();
                }
              }
            }
          } else if (svm.type === 'rbf') {
            const { points: svmPoints, gamma } = svm;
            const predictPoint = (x, y) => {
              let score = 0;
              svmPoints.forEach(p => {
                const d = Math.pow(x - p.x, 2) + Math.pow(y - p.y, 2);
                const sim = Math.exp(-gamma * d / 10000);
                score += p.class * sim;
              });
              return score;
            };

            for (let x = PADDING; x < WIDTH - PADDING; x += 3) {
              for (let y = PADDING; y < HEIGHT - PADDING; y += 3) {
                const val = predictPoint(x, y);
                const boundaryDist = Math.abs(val);
                let minDist = Infinity;
                svmPoints.forEach(p => {
                  const d = Math.sqrt(Math.pow(x - p.x, 2) + Math.pow(y - p.y, 2));
                  minDist = Math.min(minDist, d);
                });
                
                const distanceDecay = Math.exp(-minDist / 80);
                const alpha = Math.min(0.7, 
                  0.05 + 
                  Math.min(0.4, boundaryDist * 0.1) + 
                  distanceDecay * 0.5
                );
                
                ctx.fillStyle = val > 0 
                  ? `rgba(239, 68, 68, ${alpha})`
                  : `rgba(59, 130, 246, ${alpha})`;
                ctx.fillRect(x, y, 3, 3);
              }
            }

            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 3;
            for (let x = PADDING; x < WIDTH - PADDING - 4; x += 4) {
              for (let y = PADDING; y < HEIGHT - PADDING - 4; y += 4) {
                const v = [
                  predictPoint(x, y),
                  predictPoint(x + 4, y),
                  predictPoint(x + 4, y + 4),
                  predictPoint(x, y + 4)
                ];
                
                const s = v.map(val => val >= 0 ? 1 : 0);
                const cfg = s[0] * 8 + s[1] * 4 + s[2] * 2 + s[3];
                
                if (cfg !== 0 && cfg !== 15) {
                  ctx.beginPath();
                  const t1 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[1]) + 0.001);
                  const t2 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3]) + 0.001);
                  const t3 = Math.abs(v[2]) / (Math.abs(v[2]) + Math.abs(v[3]) + 0.001);
                  const t4 = Math.abs(v[2]) / (Math.abs(v[2]) + Math.abs(v[1]) + 0.001);
                  const t5 = Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[0]) + 0.001);
                  const t6 = Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[2]) + 0.001);
                  const t7 = Math.abs(v[3]) / (Math.abs(v[3]) + Math.abs(v[0]) + 0.001);
                  const t8 = Math.abs(v[3]) / (Math.abs(v[3]) + Math.abs(v[2]) + 0.001);
                  
                  switch(cfg) {
                    case 1: case 14: ctx.moveTo(x + 4 * t1, y); ctx.lineTo(x, y + 4 * t2); break;
                    case 2: case 13: ctx.moveTo(x + 4 * t3, y + 4); ctx.lineTo(x + 4, y + 4 * t4); break;
                    case 3: case 12: ctx.moveTo(x, y + 4 * t2); ctx.lineTo(x + 4, y + 4 * t6); break;
                    case 4: case 11: ctx.moveTo(x + 4 * t5, y); ctx.lineTo(x + 4, y + 4 * t6); break;
                    case 6: case 9: ctx.moveTo(x + 4 * t1, y); ctx.lineTo(x + 4 * t8, y + 4); break;
                    case 7: case 8: ctx.moveTo(x, y + 4 * t7); ctx.lineTo(x + 4 * t8, y + 4); break;
                  }
                  ctx.stroke();
                }
              }
            }
          } else if (svm.type === 'sigmoid') {
            const { hiddenCenters, hiddenWeights, bias, alpha, c0, centerX, centerY, scale } = svm;
            
            const predict = (x, y) => {
              const nx = (x - centerX) / scale;
              const ny = (y - centerY) / scale;
              
              let score = bias;
              hiddenCenters.forEach((center, i) => {
                const dx = nx - center.x;
                const dy = ny - center.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const activation = Math.tanh(alpha * (5 - dist * 10) + c0);
                score += hiddenWeights[i] * activation;
              });
              
              return score;
            };

            for (let x = PADDING; x < WIDTH - PADDING; x += 3) {
              for (let y = PADDING; y < HEIGHT - PADDING; y += 3) {
                const val = predict(x, y);
                const boundaryDist = Math.abs(val);
                const alpha = Math.min(0.25, 0.03 + boundaryDist * 0.12);
                
                ctx.fillStyle = val > 0 
                  ? `rgba(239, 68, 68, ${alpha})`
                  : `rgba(59, 130, 246, ${alpha})`;
                ctx.fillRect(x, y, 3, 3);
              }
            }

            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 3;
            for (let x = PADDING; x < WIDTH - PADDING - 4; x += 4) {
              for (let y = PADDING; y < HEIGHT - PADDING - 4; y += 4) {
                const v = [
                  predict(x, y),
                  predict(x + 4, y),
                  predict(x + 4, y + 4),
                  predict(x, y + 4)
                ];
                
                const s = v.map(val => val >= 0 ? 1 : 0);
                const cfg = s[0] * 8 + s[1] * 4 + s[2] * 2 + s[3];
                
                if (cfg !== 0 && cfg !== 15) {
                  ctx.beginPath();
                  const t1 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[1]) + 0.001);
                  const t2 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3]) + 0.001);
                  const t3 = Math.abs(v[2]) / (Math.abs(v[2]) + Math.abs(v[3]) + 0.001);
                  const t4 = Math.abs(v[2]) / (Math.abs(v[2]) + Math.abs(v[1]) + 0.001);
                  const t5 = Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[0]) + 0.001);
                  const t6 = Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[2]) + 0.001);
                  const t7 = Math.abs(v[3]) / (Math.abs(v[3]) + Math.abs(v[0]) + 0.001);
                  const t8 = Math.abs(v[3]) / (Math.abs(v[3]) + Math.abs(v[2]) + 0.001);
                  
                  switch(cfg) {
                    case 1: case 14: ctx.moveTo(x + 4 * t1, y); ctx.lineTo(x, y + 4 * t2); break;
                    case 2: case 13: ctx.moveTo(x + 4 * t3, y + 4); ctx.lineTo(x + 4, y + 4 * t4); break;
                    case 3: case 12: ctx.moveTo(x, y + 4 * t2); ctx.lineTo(x + 4, y + 4 * t6); break;
                    case 4: case 11: ctx.moveTo(x + 4 * t5, y); ctx.lineTo(x + 4, y + 4 * t6); break;
                    case 6: case 9: ctx.moveTo(x + 4 * t1, y); ctx.lineTo(x + 4 * t8, y + 4); break;
                    case 7: case 8: ctx.moveTo(x, y + 4 * t7); ctx.lineTo(x + 4 * t8, y + 4); break;
                  }
                  ctx.stroke();
                }
              }
            }
          }
        }

        points.forEach(point => {
          const isSV = svm?.supportVectors?.some(sv => Math.abs(sv.x - point.x) < 1 && Math.abs(sv.y - point.y) < 1);
          ctx.beginPath();
          ctx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
          ctx.fillStyle = point.class === 1 ? '#ef4444' : '#3b82f6';
          ctx.fill();
          ctx.strokeStyle = point.class === 1 ? '#991b1b' : '#1e40af';
          ctx.lineWidth = 2;
          ctx.stroke();
          if (isSV) {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 14, 0, 2 * Math.PI);
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 3;
            ctx.stroke();
          }
        });
      }, [points, svm]);

      const handleClick = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const scaleX = WIDTH / rect.width;
        const scaleY = HEIGHT / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        if (x >= PADDING && x <= WIDTH - PADDING && y >= PADDING && y <= HEIGHT - PADDING) {
          setPoints([...points, { x, y, class: selectedClass }]);
          setSvm(null);
        }
      };

      const handleMouseMove = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const scaleX = WIDTH / rect.width;
        const scaleY = HEIGHT / rect.height;
        const mx = (e.clientX - rect.left) * scaleX;
        const my = (e.clientY - rect.top) * scaleY;

        let found = null;
        for (let p of points) {
          if (Math.hypot(mx - p.x, my - p.y) <= 12) {
            found = p;
            break;
          }
        }
        setHovered(found);
      };

      const reset = () => {
        setPoints(generateInitialData());
        setSvm(null);
        setSelectedClass(1);
      };

      const redCount = points.filter(p => p.class === 1).length;
      const blueCount = points.filter(p => p.class === -1).length;

      return (
        <div className="max-w-6xl mx-auto bg-white rounded-2xl shadow-2xl overflow-hidden">
          <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white">
            <div className="text-sm mb-2 text-indigo-100">ë¶€ì‚°ì§„ì—¬ììƒì—…ê³ ë“±í•™êµ ì¸ê³µì§€ëŠ¥ê¸°ì´ˆ í•™ìŠµìë£Œ</div>
            <h1 className="text-3xl font-bold mb-2">ì„œí¬íŠ¸ ë²¡í„° ë¨¸ì‹ (SVM)ì´ë€ ë¬´ì—‡ì¼ê¹Œ?</h1>
            <p className="text-indigo-100">ìµœì ì˜ ê²½ê³„ì„ ì„ ì°¾ì•„ ë°ì´í„°ë¥¼ ë¶„ë¥˜í•˜ëŠ” ê°•ë ¥í•œ AI ì•Œê³ ë¦¬ì¦˜ì„ ì²´í—˜í•´ë³´ì„¸ìš”</p>
          </div>

          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 border-b border-indigo-100">
            <div className="space-y-3 text-gray-700">
              <div>
                <h3 className="font-bold text-indigo-900 text-lg mb-2">ğŸ“š SVM ì•Œê³ ë¦¬ì¦˜ì´ë€?</h3>
                <p className="leading-relaxed">
                  SVMì€ ë‘ ê·¸ë£¹ì„ <span className="font-bold text-blue-600">ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ëœ¨ë¦¬ëŠ” ê²½ê³„ì„ </span>ì„ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ì—ìš”. 
                  ì˜ˆë¥¼ ë“¤ì–´, ë°°ë“œë¯¼í„´ì„ ì¢‹ì•„í•˜ëŠ” í•™ìƒë“¤ê³¼ ëŒ„ìŠ¤ë¥¼ ì¢‹ì•„í•˜ëŠ” í•™ìƒë“¤ì„ ë‚˜ëˆŒ ë•Œ, 
                  ì–‘ìª½ ê·¸ë£¹ì—ì„œ <span className="font-bold text-yellow-600">ê°€ì¥ ê°€ê¹Œìš´ í•™ìƒë“¤(ì„œí¬íŠ¸ ë²¡í„°)</span>ê³¼ì˜ ê±°ë¦¬ê°€ 
                  <span className="font-bold text-green-600"> ìµœëŒ€í•œ ë©€ì–´ì§€ëŠ” ì¤‘ê°„ì„ </span>ì„ ì°¾ëŠ” ê²ƒê³¼ ê°™ì•„ìš”!
                </p>
              </div>
              
              <div className="grid md:grid-cols-4 gap-4 mt-4">
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-indigo-700 mb-2">1ï¸âƒ£ ë°ì´í„° ì¶”ê°€</h4>
                  <p className="text-sm">í´ë˜ìŠ¤ A ë˜ëŠ” í´ë˜ìŠ¤ B ë²„íŠ¼ì„ ì„ íƒí•œ í›„ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì—¬ í•™ìŠµ ë°ì´í„°ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-green-700 mb-2">2ï¸âƒ£ ì»¤ë„ ì„ íƒ</h4>
                  <p className="text-sm">ì§ì„ , ë‹¤í•­ì‹, RBF, ì‹œê·¸ëª¨ì´ë“œ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì—¬ ë‹¤ì–‘í•œ í˜•íƒœì˜ ê²½ê³„ì„ ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-orange-700 mb-2">3ï¸âƒ£ Cost ì¡°ì •</h4>
                  <p className="text-sm">ì—„ê²©í•¨(ë†’ì€ C) vs ìœ ì—°í•¨(ë‚®ì€ C)ì„ ì¡°ì ˆí•˜ì—¬ ê²½ê³„ì„ ì´ ë°ì´í„°ë¥¼ ì–¼ë§ˆë‚˜ ì •í™•íˆ ë”°ë¼ê°ˆì§€ ê²°ì •í•©ë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-purple-700 mb-2">4ï¸âƒ£ í•™ìŠµ ì‹¤í–‰</h4>
                  <p className="text-sm">'í•™ìŠµ ì‹œì‘!' ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ AIê°€ ìµœì ì˜ ê²°ì • ê²½ê³„ì™€ ì„œí¬íŠ¸ ë²¡í„°ë¥¼ ì°¾ì•„ëƒ…ë‹ˆë‹¤.</p>
                </div>
              </div>
            </div>
          </div>

          <div className="p-6">
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
              <div className="space-y-4">
                <div className="bg-indigo-50 p-4 rounded-lg border border-indigo-200">
                  <h3 className="font-bold text-indigo-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">âš™ï¸</span>
                    <span>ì»¤ë„ ì„¤ì •</span>
                  </h3>
                  
                  <div className="space-y-2">
                    <button onClick={() => { setKernelMode('linear'); setSvm(null); }}
                      className={`w-full py-2 px-3 rounded-lg font-medium transition-all ${kernelMode === 'linear' ? 'bg-purple-500 text-white shadow-md' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}`}>
                      ì§ì„  ì»¤ë„
                    </button>
                    <button onClick={() => { setKernelMode('polynomial'); setSvm(null); }}
                      className={`w-full py-2 px-3 rounded-lg font-medium transition-all ${kernelMode === 'polynomial' ? 'bg-purple-500 text-white shadow-md' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}`}>
                      ë‹¤í•­ì‹ ì»¤ë„
                    </button>
                    <button onClick={() => { setKernelMode('rbf'); setSvm(null); }}
                      className={`w-full py-2 px-3 rounded-lg font-medium transition-all ${kernelMode === 'rbf' ? 'bg-purple-500 text-white shadow-md' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}`}>
                      RBF ì»¤ë„
                    </button>
                    <button onClick={() => { setKernelMode('sigmoid'); setSvm(null); }}
                      className={`w-full py-2 px-3 rounded-lg font-medium transition-all ${kernelMode === 'sigmoid' ? 'bg-purple-500 text-white shadow-md' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}`}>
                      ì‹œê·¸ëª¨ì´ë“œ ì»¤ë„
                    </button>
                  </div>

                  {kernelMode === 'polynomial' && (
                    <div className="mt-3">
                      <label className="text-sm text-gray-600 block mb-1">
                        ì°¨ìˆ˜: {polynomialDegree} {svm && <span className="text-green-600">âœ“ ì ìš©ë¨</span>}
                      </label>
                      <input type="range" min="2" max="3" value={polynomialDegree} 
                        onChange={(e) => { setPolynomialDegree(parseInt(e.target.value)); }} 
                        className="w-full" />
                      <p className="text-xs text-gray-500 mt-1">*ì°¨ìˆ˜ê°€ ë†’ì„ìˆ˜ë¡ ë³µì¡í•œ ê³¡ì„  ê°€ëŠ¥</p>
                    </div>
                  )}
                  {kernelMode === 'rbf' && (
                    <div className="mt-3">
                      <label className="text-sm text-gray-600 block mb-1">
                        Î³ (ê°ë§ˆ): {rbfGamma.toFixed(2)} {svm && <span className="text-green-600">âœ“ ì ìš©ë¨</span>}
                      </label>
                      <input type="range" min="0.1" max="2" step="0.1" value={rbfGamma} 
                        onChange={(e) => { setRbfGamma(parseFloat(e.target.value)); }} 
                        className="w-full" />
                      <p className="text-xs text-gray-500 mt-1">*ê°’ì´ í´ìˆ˜ë¡ ê²½ê³„ê°€ ë³µì¡í•´ì§</p>
                    </div>
                  )}
                  {kernelMode === 'sigmoid' && (
                    <div className="mt-3 space-y-3">
                      <div>
                        <label className="text-sm text-gray-600 block mb-1">
                          Î± (ì•ŒíŒŒ): {sigmoidAlpha.toFixed(3)} {svm && <span className="text-green-600">âœ“ ì ìš©ë¨</span>}
                        </label>
                        <input type="range" min="0.001" max="0.1" step="0.001" value={sigmoidAlpha} 
                          onChange={(e) => { setSigmoidAlpha(parseFloat(e.target.value)); }} 
                          className="w-full" />
                        <p className="text-xs text-gray-500 mt-1">*ê²½ê³„ì˜ ê¸°ìš¸ê¸° ì¡°ì ˆ</p>
                      </div>
                      <div>
                        <label className="text-sm text-gray-600 block mb-1">
                          câ‚€ (ìƒìˆ˜): {sigmoidC0.toFixed(2)} {svm && <span className="text-green-600">âœ“ ì ìš©ë¨</span>}
                        </label>
                        <input type="range" min="-2" max="2" step="0.1" value={sigmoidC0} 
                          onChange={(e) => { setSigmoidC0(parseFloat(e.target.value)); }} 
                          className="w-full" />
                        <p className="text-xs text-gray-500 mt-1">*ê²½ê³„ì˜ ìœ„ì¹˜ ì¡°ì ˆ</p>
                      </div>
                    </div>
                  )}
                </div>

                <div className="bg-orange-50 p-4 rounded-lg border border-orange-200">
                  <h3 className="font-bold text-orange-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ’ª</span>
                    <span>Cost (C) íŒŒë¼ë¯¸í„°</span>
                  </h3>
                  <div className="mb-3">
                    <label className="text-sm text-gray-600 block mb-1">
                      C ê°’: {costC.toFixed(1)} {svm && <span className="text-green-600">âœ“ ì ìš©ë¨</span>}
                    </label>
                    <input 
                      type="range" 
                      min="0.1" 
                      max="10" 
                      step="0.1" 
                      value={costC} 
                      onChange={(e) => { setCostC(parseFloat(e.target.value)); }} 
                      className="w-full" 
                    />
                  </div>
                  <div className="bg-white p-3 rounded-lg text-xs space-y-2">
                    <div className={`p-2 rounded ${costC >= 5 ? 'bg-red-100 border border-red-300' : 'bg-gray-50'}`}>
                      <p className="font-semibold text-red-700">ë†’ì€ C (ì—„ê²©)</p>
                      <p className="text-gray-600">ì˜¤ë¥˜ë¥¼ ê±°ì˜ í—ˆìš©í•˜ì§€ ì•ŠìŒ. ë°ì´í„°ì— ë”± ë§ì¶¤ â†’ ê³¼ì í•© ìœ„í—˜ âš ï¸</p>
                    </div>
                    <div className={`p-2 rounded ${costC <= 1 ? 'bg-blue-100 border border-blue-300' : 'bg-gray-50'}`}>
                      <p className="font-semibold text-blue-700">ë‚®ì€ C (ìœ ì—°)</p>
                      <p className="text-gray-600">ì˜¤ë¥˜ë¥¼ ì–´ëŠì •ë„ í—ˆìš©. ë¶€ë“œëŸ¬ìš´ ê²½ê³„ â†’ ì¼ë°˜í™” ì„±ëŠ¥ âœ…</p>
                    </div>
                  </div>
                </div>

                <div className="bg-green-50 p-4 rounded-lg border border-green-200">
                  <h3 className="font-bold text-green-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ“Š</span>
                    <span>ë°ì´í„° ì…ë ¥</span>
                  </h3>
                  <div className="space-y-2">
                    <button onClick={() => setSelectedClass(1)}
                      className={`w-full p-3 rounded-lg font-semibold transition-all ${selectedClass === 1 ? 'bg-red-500 text-white shadow-lg scale-105' : 'bg-white text-red-600 border-2 border-red-300 hover:bg-red-50'}`}>
                      í´ë˜ìŠ¤ A ì¶”ê°€
                    </button>
                    <button onClick={() => setSelectedClass(-1)}
                      className={`w-full p-3 rounded-lg font-semibold transition-all ${selectedClass === -1 ? 'bg-blue-500 text-white shadow-lg scale-105' : 'bg-white text-blue-600 border-2 border-blue-300 hover:bg-blue-50'}`}>
                      í´ë˜ìŠ¤ B ì¶”ê°€
                    </button>
                  </div>
                  <div className="mt-3 text-xs text-gray-600 bg-white p-2 rounded">
                    ğŸ’¡ í•™ìŠµ í›„ ìŠ¬ë¼ì´ë”ë¥¼ ì›€ì§ì´ë©´ ìë™ìœ¼ë¡œ ì¬í•™ìŠµë©ë‹ˆë‹¤!
                  </div>
                </div>

                <div className="bg-slate-50 p-4 rounded-lg border border-slate-200">
                  <h3 className="font-bold text-slate-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ®</span>
                    <span>ë™ì‘</span>
                  </h3>
                  <div className="space-y-2">
                    <button onClick={handleTrain} disabled={points.length < 2}
                      className="w-full bg-green-500 text-white py-3 rounded-lg font-semibold hover:bg-green-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-all">
                      í•™ìŠµ ì‹œì‘!
                    </button>
                    <button onClick={() => { setPoints([]); setSvm(null); }}
                      className="w-full bg-orange-500 text-white py-3 rounded-lg font-semibold hover:bg-orange-600 transition-all">
                      ëª¨ë‘ ì§€ìš°ê¸°
                    </button>
                    <button onClick={reset}
                      className="w-full bg-gray-500 text-white py-3 rounded-lg font-semibold hover:bg-gray-600 transition-all">
                      ì´ˆê¸°í™”
                    </button>
                  </div>
                </div>

                <div className="bg-pink-50 p-4 rounded-lg border border-pink-200">
                  <h3 className="font-bold text-pink-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ“ˆ</span>
                    <span>ë°ì´í„° í˜„í™©</span>
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">í´ë˜ìŠ¤ A:</span>
                      <span className="font-bold text-red-600">{redCount}ê°œ</span>
                    </div>
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">í´ë˜ìŠ¤ B:</span>
                      <span className="font-bold text-blue-600">{blueCount}ê°œ</span>
                    </div>
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">ì „ì²´:</span>
                      <span className="font-bold">{points.length}ê°œ</span>
                    </div>
                    {svm && svm.supportVectors && (
                      <div className="flex justify-between items-center p-2 bg-yellow-100 rounded">
                        <span className="font-medium">ì„œí¬íŠ¸ ë²¡í„°:</span>
                        <span className="font-bold text-yellow-700">{svm.supportVectors.length}ê°œ</span>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              <div className="lg:col-span-3 space-y-4">
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                  <h3 className="font-bold text-gray-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ¯</span>
                    <span>2ì°¨ì› íŠ¹ì„± ê³µê°„</span>
                  </h3>
                  <div className="relative bg-white rounded-lg shadow-inner overflow-hidden border-2 border-gray-300">
                    <canvas ref={canvasRef} width={WIDTH} height={HEIGHT} 
                      onClick={handleClick} onMouseMove={handleMouseMove} 
                      onMouseLeave={() => setHovered(null)}
                      className="block w-full cursor-crosshair" />
                    {hovered && (
                      <div className="absolute bg-gray-900 text-white text-xs px-3 py-1 rounded-md pointer-events-none shadow-lg"
                        style={{ left: hovered.x + 15, top: hovered.y - 10 }}>
                        {hovered.class === 1 ? 'í´ë˜ìŠ¤ A' : 'í´ë˜ìŠ¤ B'}
                      </div>
                    )}
                  </div>

                  {svm && (
                    <div className="mt-4 bg-gradient-to-r from-green-50 to-emerald-50 p-5 rounded-lg border-2 border-green-400">
                      <h3 className="text-xl font-bold text-green-800 mb-3 flex items-center gap-2">
                        <span>âœ…</span>
                        <span>í•™ìŠµ ì™„ë£Œ!</span>
                      </h3>
                      <div className="space-y-3">
                        <div className="bg-white p-4 rounded-lg shadow-sm">
                          <p className="font-semibold text-gray-800 mb-2">
                            ğŸ” {kernelMode === 'linear' ? 'ì§ì„  ì»¤ë„' : kernelMode === 'polynomial' ? `ë‹¤í•­ì‹ ì»¤ë„ (${polynomialDegree}ì°¨)` : kernelMode === 'sigmoid' ? `ì‹œê·¸ëª¨ì´ë“œ ì»¤ë„ (Î±=${sigmoidAlpha.toFixed(3)})` : `RBF ì»¤ë„ (Î³=${rbfGamma.toFixed(2)})`} | Cost = {costC.toFixed(1)}
                          </p>
                          <div className="space-y-2 text-sm text-gray-700">
                            {kernelMode === 'linear' && (
                              <>
                                <p>â€¢ <span className="font-semibold text-green-600">ë…¹ìƒ‰ ì‹¤ì„ </span>: ë‘ í´ë˜ìŠ¤ë¥¼ ë‚˜ëˆ„ëŠ” ê²°ì • ê²½ê³„</p>
                                <p>â€¢ <span className="font-semibold text-blue-400">íŒŒë€ ì ì„ </span>: ë§ˆì§„ ê²½ê³„ (ì„œí¬íŠ¸ ë²¡í„°ì™€ì˜ ê±°ë¦¬)</p>
                                <p>â€¢ ë‘ ì ì„  ì‚¬ì´ì˜ ê±°ë¦¬ê°€ <span className="font-bold text-green-600">ë§ˆì§„</span>ì…ë‹ˆë‹¤</p>
                                {costC >= 5 && <p className="text-red-600 font-semibold">âš ï¸ ë†’ì€ Cê°’: ë§ˆì§„ì´ ì¢ê³  ì—„ê²©í•œ ê²½ê³„ì„ </p>}
                                {costC <= 1 && <p className="text-blue-600 font-semibold">âœ… ë‚®ì€ Cê°’: ë§ˆì§„ì´ ë„“ê³  ìœ ì—°í•œ ê²½ê³„ì„ </p>}
                              </>
                            )}
                            {kernelMode === 'polynomial' && (
                              <>
                                <p>â€¢ <span className="font-semibold text-green-600">ë…¹ìƒ‰ ê³¡ì„ </span>: ê³¡ì„  í˜•íƒœì˜ ê²°ì • ê²½ê³„</p>
                                <p>â€¢ íƒ€ì›, í¬ë¬¼ì„  ë“± ë³µì¡í•œ íŒ¨í„´ ë¶„ë¥˜ ê°€ëŠ¥</p>
                                <p>â€¢ ë°°ê²½ìƒ‰ìœ¼ë¡œ ê° ì˜ì—­ì˜ ì†Œì† í´ë˜ìŠ¤ í‘œì‹œ</p>
                                {costC >= 5 && <p className="text-red-600 font-semibold">âš ï¸ ë†’ì€ Cê°’: ë°ì´í„°ì— ê³¼í•˜ê²Œ ë§ì¶¤</p>}
                                {costC <= 1 && <p className="text-blue-600 font-semibold">âœ… ë‚®ì€ Cê°’: ì¼ë°˜í™”ëœ íŒ¨í„´ í•™ìŠµ</p>}
                              </>
                            )}
                            {kernelMode === 'rbf' && (
                              <>
                                <p>â€¢ <span className="font-semibold text-green-600">ë…¹ìƒ‰ ê³¡ì„ </span>: ììœ ë¡œìš´ í˜•íƒœì˜ ê²°ì • ê²½ê³„</p>
                                <p>â€¢ ì ì—ì„œ ë©€ì–´ì§ˆìˆ˜ë¡ ìƒ‰ì´ ì—°í•´ì§€ëŠ” ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼</p>
                                <p>â€¢ ê°€ì¥ ë³µì¡í•œ íŒ¨í„´ë„ ë¶„ë¥˜ ê°€ëŠ¥!</p>
                                {costC >= 5 && <p className="text-red-600 font-semibold">âš ï¸ ë†’ì€ Cê°’: ê° ì ë§ˆë‹¤ ì •í™•íˆ ë§ì¶¤ (ê³¼ì í•©)</p>}
                                {costC <= 1 && <p className="text-blue-600 font-semibold">âœ… ë‚®ì€ Cê°’: ì „ì²´ì ì¸ ê²½í–¥ íŒŒì•…</p>}
                              </>
                            )}
                            {kernelMode === 'sigmoid' && (
                              <>
                                <p>â€¢ <span className="font-semibold text-green-600">ë…¹ìƒ‰ ê³¡ì„ </span>: Sì í˜•íƒœì˜ ë¹„ì„ í˜• ê²°ì • ê²½ê³„</p>
                                <p>â€¢ ì‹ ê²½ë§ì²˜ëŸ¼ ì—¬ëŸ¬ ê°œì˜ sigmoid(Sì) í•¨ìˆ˜ë¥¼ ì¡°í•©í•˜ì—¬ ë™ì‘</p>
                                <p>â€¢ ë³µì¡í•˜ê³  êµ¬ë¶ˆêµ¬ë¶ˆí•œ íŒ¨í„´ë„ í•™ìŠµ ê°€ëŠ¥</p>
                                {costC >= 5 && <p className="text-red-600 font-semibold">âš ï¸ ë†’ì€ Cê°’: ë°ì´í„°ì— ë§¤ìš° ë¯¼ê°í•œ ë³µì¡í•œ ê²½ê³„</p>}
                                {costC <= 1 && <p className="text-blue-600 font-semibold">âœ… ë‚®ì€ Cê°’: ì „ì²´ì ì¸ ê²½í–¥ì„ ë”°ë¥´ëŠ” ë¶€ë“œëŸ¬ìš´ ê²½ê³„</p>}
                              </>
                            )}
                            <p className="mt-2 pt-2 border-t border-gray-200">
                              â€¢ <span className="inline-block w-3 h-3 rounded-full border-2 border-yellow-500 mr-1"></span>
                              <span className="font-semibold text-yellow-600">ë…¸ë€ í…Œë‘ë¦¬</span>: 
                              ê²°ì • ê²½ê³„ì— ê°€ì¥ ê°€ê¹Œìš´ ì¤‘ìš”í•œ ì ë“¤ (ì„œí¬íŠ¸ ë²¡í„°)
                            </p>
                          </div>
                        </div>

                        <div className="bg-indigo-50 p-4 rounded-lg">
                          <p className="text-sm font-semibold text-indigo-900 mb-2">ğŸ’¡ Cost(C) íŒŒë¼ë¯¸í„°ì˜ ì—­í• </p>
                          <p className="text-sm text-gray-700 leading-relaxed">
                            CostëŠ” <span className="font-bold text-orange-600">"ì–¼ë§ˆë‚˜ ì—„ê²©í•˜ê²Œ ë¶„ë¥˜í•  ê²ƒì¸ê°€?"</span>ë¥¼ ê²°ì •í•©ë‹ˆë‹¤. 
                            <span className="font-bold text-red-600">ë†’ì€ C</span>ëŠ” ëª¨ë“  ë°ì´í„°ë¥¼ ì •í™•íˆ ë¶„ë¥˜í•˜ë ¤ê³  í•´ì„œ ë³µì¡í•œ ê²½ê³„ë¥¼ ë§Œë“¤ê³ , 
                            <span className="font-bold text-blue-600">ë‚®ì€ C</span>ëŠ” ëª‡ ê°œì˜ ì˜¤ë¥˜ë¥¼ í—ˆìš©í•˜ë”ë¼ë„ ë‹¨ìˆœí•˜ê³  ì¼ë°˜í™”ëœ ê²½ê³„ë¥¼ ë§Œë“­ë‹ˆë‹¤.
                            ë§ˆì¹˜ ì‹œí—˜ì—ì„œ 100ì ë§Œ ë°›ìœ¼ë ¤ëŠ” ê²ƒ(ë†’ì€ C) vs 80ì  ì •ë„ë©´ ë§Œì¡±í•˜ëŠ” ê²ƒ(ë‚®ì€ C)ì˜ ì°¨ì´ì™€ ê°™ì•„ìš”!
                          </p>
                        </div>

                        <div className="bg-purple-50 p-4 rounded-lg">
                          <p className="text-sm font-semibold text-purple-900 mb-2">ğŸ¯ SVMì˜ í•µì‹¬ ì•„ì´ë””ì–´</p>
                          <p className="text-sm text-gray-700 leading-relaxed">
                            SVMì€ ë‹¨ìˆœíˆ ê²½ê³„ì„ ì„ ê·¸ë¦¬ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, <span className="font-bold text-purple-600">ì–‘ìª½ í´ë˜ìŠ¤ì™€ ìµœëŒ€í•œ ë©€ë¦¬ ë–¨ì–´ì§„ ê²½ê³„ì„ </span>ì„ ì°¾ìŠµë‹ˆë‹¤. 
                            ì´ë ‡ê²Œ í•˜ë©´ ìƒˆë¡œìš´ ë°ì´í„°ê°€ ë“¤ì–´ì™”ì„ ë•Œë„ ì •í™•í•˜ê²Œ ë¶„ë¥˜í•  ìˆ˜ ìˆì–´ìš”! 
                            <span className="font-bold text-yellow-600">ì„œí¬íŠ¸ ë²¡í„°</span>ëŠ” ì´ ê²½ê³„ì„ ì„ ê²°ì •í•˜ëŠ” ë° ê°€ì¥ ì¤‘ìš”í•œ ì—­í• ì„ í•˜ëŠ” ì ë“¤ì…ë‹ˆë‹¤.
                          </p>
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                <div className="flex justify-center gap-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
                  <div className="flex items-center gap-2" title="ì§€ë„êµì‚¬ ê¹€ë™ì£¼">
                    <div className="w-5 h-5 bg-red-500 rounded-full border-2 border-gray-800"></div>
                    <span className="font-medium text-gray-700">í´ë˜ìŠ¤ A (ë°°ë“œë¯¼í„´ë°˜)</span>
                  </div>
                  <div className="flex items-center gap-2" title="ë² ì•„íŠ¸ë¦¬ìŠ¤">
                    <div className="w-5 h-5 bg-blue-500 rounded-full border-2 border-gray-800"></div>
                    <span className="font-medium text-gray-700">í´ë˜ìŠ¤ B (ëŒ„ìŠ¤ë°˜)</span>
                  </div>
                  <div className="flex items-center gap-2 cursor-pointer relative" onClick={() => {
                    setShowSVTooltip(true);
                    setTimeout(() => setShowSVTooltip(false), 500);
                  }}>
                    <div className="w-5 h-5 bg-white rounded-full border-4 border-yellow-500"></div>
                    <span className="font-medium text-gray-700">ì„œí¬íŠ¸ ë²¡í„°</span>
                    {showSVTooltip && (
    <div className="absolute bottom-full mb-2 left-1/2 transform -translate-x-1/2 bg-yellow-900 text-white text-xs px-4 py-2 rounded-lg shadow-lg whitespace-nowrap z-50">
      ğŸ‰ ì°¸ìƒˆë‹¤!
      <div className="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-yellow-900"></div>
    </div>
  )}
                  </div>
                </div>

                <div className="bg-gradient-to-r from-purple-50 to-pink-50 p-5 rounded-lg border border-purple-200">
                  <h3 className="text-lg font-bold text-purple-900 mb-3">ğŸ§  ì»¤ë„ì˜ ì¢…ë¥˜ ì´í•´í•˜ê¸°</h3>
                  <div className="grid md:grid-cols-4 gap-4">
                    <div className="bg-white p-4 rounded-lg shadow-sm">
                      <h4 className="font-bold text-purple-600 mb-2">ì§ì„  ì»¤ë„ ğŸ“</h4>
                      <p className="text-sm text-gray-700">
                        ê°€ì¥ ë‹¨ìˆœí•œ í˜•íƒœì˜ˆìš”. ë°ì´í„°ë¥¼ ì§ì„ ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆì„ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. 
                        ë¹ ë¥´ê³  ê°„ë‹¨í•˜ì§€ë§Œ, ë³µì¡í•œ íŒ¨í„´ì€ ë¶„ë¥˜í•˜ê¸° ì–´ë ¤ì›Œìš”.
                      </p>
                    </div>
                    <div className="bg-white p-4 rounded-lg shadow-sm">
                      <h4 className="font-bold text-purple-600 mb-2">ë‹¤í•­ì‹ ì»¤ë„ ğŸ“</h4>
                      <p className="text-sm text-gray-700">
                        ê³¡ì„ ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë‚˜ëˆŒ ìˆ˜ ìˆì–´ìš”. íƒ€ì›ì´ë‚˜ í¬ë¬¼ì„  ê°™ì€ ëª¨ì–‘ìœ¼ë¡œ 
                        ê²½ê³„ë¥¼ ë§Œë“¤ ìˆ˜ ìˆì–´ì„œ ì¡°ê¸ˆ ë” ë³µì¡í•œ íŒ¨í„´ì„ ë¶„ë¥˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                      </p>
                    </div>
                    <div className="bg-white p-4 rounded-lg shadow-sm">
                      <h4 className="font-bold text-purple-600 mb-2">RBF ì»¤ë„ ğŸ¨</h4>
                      <p className="text-sm text-gray-700">
                        ê°€ì¥ ìœ ì—°í•œ í˜•íƒœì˜ˆìš”! ì ì—ì„œ ê°€ê¹Œìš¸ìˆ˜ë¡ ì˜í–¥ì´ í¬ê³ , ë©€ìˆ˜ë¡ 
                        ì˜í–¥ì´ ì‘ì•„ì§€ëŠ” ì›ë¦¬ë¡œ ì•„ì£¼ ë³µì¡í•œ íŒ¨í„´ë„ ë¶„ë¥˜í•  ìˆ˜ ìˆì–´ìš”.
                      </p>
                    </div>
                    <div className="bg-white p-4 rounded-lg shadow-sm">
                      <h4 className="font-bold text-purple-600 mb-2">ì‹œê·¸ëª¨ì´ë“œ ì»¤ë„ ğŸ§®</h4>
                      <p className="text-sm text-gray-700">
                        Sì ê³¡ì„ (sigmoid)ì„ ì‚¬ìš©í•˜ëŠ” ì»¤ë„ì´ì—ìš”! 
                        ì‹ ê²½ë§ì²˜ëŸ¼ ì—¬ëŸ¬ ê°œì˜ Sì í•¨ìˆ˜ë¥¼ ì¡°í•©í•´ì„œ 
                        ë³µì¡í•˜ê³  êµ¬ë¶ˆêµ¬ë¶ˆí•œ ê²½ê³„ì„ ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
                        ë”¥ëŸ¬ë‹ê³¼ ì—°ê²°ë˜ëŠ” ë°©ì‹ì´ë¼ í¥ë¯¸ë¡œì›Œìš”!
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SVMDemo />);
  </script>
</body>
</html>