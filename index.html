<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SVM ì•Œê³ ë¦¬ì¦˜</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { 
      font-family: 'Malgun Gothic', sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
    }
    canvas { image-rendering: auto; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const SVMDemo = () => {
      const canvasRef = useRef(null);
      const WIDTH = 600;
      const HEIGHT = 500;
      const PADDING = 50;

      const generateInitialData = () => {
        const initialPoints = [];
        for (let i = 0; i < 8; i++) {
          initialPoints.push({
            x: PADDING + 50 + Math.random() * 150,
            y: PADDING + 50 + Math.random() * 150,
            class: 1
          });
        }
        for (let i = 0; i < 8; i++) {
          initialPoints.push({
            x: WIDTH - PADDING - 200 + Math.random() * 150,
            y: HEIGHT - PADDING - 200 + Math.random() * 150,
            class: -1
          });
        }
        return initialPoints;
      };

      const [points, setPoints] = useState(generateInitialData());
      const [selectedClass, setSelectedClass] = useState(1);
      const [kernelMode, setKernelMode] = useState('linear');
      const [polynomialDegree, setPolynomialDegree] = useState(2);
      const [rbfGamma, setRbfGamma] = useState(0.5);
      const [svm, setSvm] = useState(null);
      const [hovered, setHovered] = useState(null);

      const trainLinearSVM = () => {
        if (points.length < 2) return null;
        const class1Points = points.filter(p => p.class === 1);
        const class2Points = points.filter(p => p.class === -1);
        if (class1Points.length === 0 || class2Points.length === 0) return null;

        let bestMargin = -Infinity;
        let bestParams = null;

        for (let angle = 0; angle < 180; angle += 2) {
          const rad = (angle * Math.PI) / 180;
          const a = Math.cos(rad);
          const b = Math.sin(rad);
          const projections = points.map(p => ({
            value: a * p.x + b * p.y,
            class: p.class,
            point: p
          }));

          const proj1 = projections.filter(p => p.class === 1);
          const proj2 = projections.filter(p => p.class === -1);
          const max1 = Math.max(...proj1.map(p => p.value));
          const min1 = Math.min(...proj1.map(p => p.value));
          const max2 = Math.max(...proj2.map(p => p.value));
          const min2 = Math.min(...proj2.map(p => p.value));

          if (max1 < min2 || max2 < min1) {
            const boundary = (Math.max(min1, min2) + Math.min(max1, max2)) / 2;
            const c = -boundary;
            const margin = Math.min(Math.abs(boundary - max1), Math.abs(boundary - min2));

            if (margin > bestMargin) {
              bestMargin = margin;
              const supportVectors = [];
              const maxValue = Math.max(...proj1.map(p => p.value));
              const minValue = Math.min(...proj2.map(p => p.value));
              
              proj1.forEach(p => {
                if (Math.abs(p.value - maxValue) < 0.1) supportVectors.push(p.point);
              });
              proj2.forEach(p => {
                if (Math.abs(p.value - minValue) < 0.1) supportVectors.push(p.point);
              });
              bestParams = { a, b, c, margin, supportVectors };
            }
          }
        }

        if (!bestParams) {
          const center1 = {
            x: class1Points.reduce((sum, p) => sum + p.x, 0) / class1Points.length,
            y: class1Points.reduce((sum, p) => sum + p.y, 0) / class1Points.length
          };
          const center2 = {
            x: class2Points.reduce((sum, p) => sum + p.x, 0) / class2Points.length,
            y: class2Points.reduce((sum, p) => sum + p.y, 0) / class2Points.length
          };
          const midX = (center1.x + center2.x) / 2;
          const midY = (center1.y + center2.y) / 2;
          const dx = center1.x - center2.x;
          const dy = center1.y - center2.y;
          const norm = Math.sqrt(dx * dx + dy * dy);
          const a = dy / norm;
          const b = -dx / norm;
          const c = -(a * midX + b * midY);
          let minDist = Infinity;
          const supportVectors = [];
          points.forEach(p => {
            const dist = Math.abs(a * p.x + b * p.y + c);
            if (dist < minDist + 0.1) {
              if (dist < minDist) {
                minDist = dist;
                supportVectors.length = 0;
              }
              supportVectors.push(p);
            }
          });
          bestParams = { a, b, c, margin: minDist, supportVectors };
        }
        return bestParams;
      };

      const trainPolynomialSVM = () => {
        if (points.length < 2) return null;
        const class1Points = points.filter(p => p.class === 1);
        const class2Points = points.filter(p => p.class === -1);
        if (class1Points.length === 0 || class2Points.length === 0) return null;

        // ì‹¤ì œ ë°ì´í„°ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
        const allX = points.map(p => p.x);
        const allY = points.map(p => p.y);
        const centerX = (Math.max(...allX) + Math.min(...allX)) / 2;
        const centerY = (Math.max(...allY) + Math.min(...allY)) / 2;
        const rangeX = Math.max(...allX) - Math.min(...allX);
        const rangeY = Math.max(...allY) - Math.min(...allY);
        const scale = Math.max(rangeX, rangeY) / 2 + 50;

        const transformPoint = (p, degree) => {
          const nx = (p.x - centerX) / scale;
          const ny = (p.y - centerY) / scale;
          const features = [1, nx, ny];
          if (degree >= 2) features.push(nx * nx, nx * ny, ny * ny);
          if (degree >= 3) features.push(nx * nx * nx, nx * nx * ny, nx * ny * ny, ny * ny * ny);
          return features;
        };

        const transformedData = points.map(p => ({
          features: transformPoint(p, polynomialDegree),
          class: p.class,
          original: p
        }));

        let weights = Array(transformedData[0].features.length).fill(0).map(() => (Math.random() - 0.5) * 0.1);
        for (let epoch = 0; epoch < 200; epoch++) {
          let errors = 0;
          transformedData.forEach(d => {
            const prediction = weights.reduce((sum, w, i) => sum + w * d.features[i], 0);
            if ((prediction >= 0 ? 1 : -1) !== d.class) {
              errors++;
              for (let i = 0; i < weights.length; i++) {
                weights[i] += 0.1 * d.class * d.features[i];
              }
            }
          });
          if (errors === 0) break;
        }

        const supportVectors = [];
        transformedData.forEach(d => {
          const value = weights.reduce((sum, w, i) => sum + w * d.features[i], 0);
          if (Math.abs(value) < 0.5) supportVectors.push(d.original);
        });

        return { weights, supportVectors, degree: polynomialDegree, centerX, centerY, scale };
      };

      const trainRBFSVM = () => {
        if (points.length < 2) return null;
        const class1Points = points.filter(p => p.class === 1);
        const class2Points = points.filter(p => p.class === -1);
        if (class1Points.length === 0 || class2Points.length === 0) return null;
        return { points: [...points], gamma: rbfGamma, supportVectors: [...points] };
      };

      const handleTrain = () => {
        if (kernelMode === 'linear') {
          const result = trainLinearSVM();
          setSvm(result ? { ...result, type: 'linear' } : null);
        } else if (kernelMode === 'polynomial') {
          const result = trainPolynomialSVM();
          setSvm(result ? { ...result, type: 'polynomial' } : null);
        } else if (kernelMode === 'rbf') {
          const result = trainRBFSVM();
          setSvm(result ? { ...result, type: 'rbf' } : null);
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        ctx.strokeStyle = '#e0e7ff';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
          const x = PADDING + (WIDTH - 2 * PADDING) * i / 10;
          const y = PADDING + (HEIGHT - 2 * PADDING) * i / 10;
          ctx.beginPath();
          ctx.moveTo(x, PADDING);
          ctx.lineTo(x, HEIGHT - PADDING);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(PADDING, y);
          ctx.lineTo(WIDTH - PADDING, y);
          ctx.stroke();
        }

        if (svm) {
          if (svm.type === 'linear') {
            const { a, b, c, margin } = svm;
            const drawLine = (offset, style, width, dash = []) => {
              ctx.strokeStyle = style;
              ctx.lineWidth = width;
              ctx.setLineDash(dash);
              ctx.beginPath();
              if (Math.abs(b) < 0.01) {
                const x = -(c + offset) / a;
                ctx.moveTo(x, PADDING);
                ctx.lineTo(x, HEIGHT - PADDING);
              } else {
                const x1 = PADDING;
                const y1 = -(a * x1 + c + offset) / b;
                const x2 = WIDTH - PADDING;
                const y2 = -(a * x2 + c + offset) / b;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
              }
              ctx.stroke();
            };
            drawLine(0, '#2563eb', 3);
            drawLine(-margin, '#93c5fd', 2, [5, 5]);
            drawLine(margin, '#93c5fd', 2, [5, 5]);
            ctx.setLineDash([]);
          } else if (svm.type === 'polynomial') {
            const { weights, degree, centerX, centerY, scale } = svm;
            const predict = (x, y) => {
              const nx = (x - centerX) / scale;
              const ny = (y - centerY) / scale;
              const features = [1, nx, ny];
              if (degree >= 2) features.push(nx * nx, nx * ny, ny * ny);
              if (degree >= 3) features.push(nx * nx * nx, nx * nx * ny, nx * ny * ny, ny * ny * ny);
              return weights.reduce((sum, w, i) => sum + w * features[i], 0);
            };

            for (let x = PADDING; x < WIDTH - PADDING; x += 5) {
              for (let y = PADDING; y < HEIGHT - PADDING; y += 5) {
                ctx.fillStyle = predict(x, y) > 0 ? 'rgba(239, 68, 68, 0.1)' : 'rgba(59, 130, 246, 0.1)';
                ctx.fillRect(x, y, 5, 5);
              }
            }

            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            for (let x = PADDING; x < WIDTH - PADDING - 4; x += 4) {
              for (let y = PADDING; y < HEIGHT - PADDING - 4; y += 4) {
                const v = [predict(x, y), predict(x + 4, y), predict(x + 4, y + 4), predict(x, y + 4)];
                const s = v.map(val => val >= 0 ? 1 : 0);
                const cfg = s[0] * 8 + s[1] * 4 + s[2] * 2 + s[3];
                if (cfg !== 0 && cfg !== 15) {
                  ctx.beginPath();
                  if (cfg === 1 || cfg === 14) {
                    ctx.moveTo(x + 4 * Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[1])), y);
                    ctx.lineTo(x, y + 4 * Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3])));
                  } else if (cfg === 3 || cfg === 12) {
                    ctx.moveTo(x, y + 4 * Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3])));
                    ctx.lineTo(x + 4, y + 4 * Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[2])));
                  }
                  ctx.stroke();
                }
              }
            }
          } else if (svm.type === 'rbf') {
            const { points: svmPoints, gamma } = svm;
            const predictPoint = (x, y) => {
              let redSum = 0, blueSum = 0;
              svmPoints.forEach(p => {
                const d = Math.pow(x - p.x, 2) + Math.pow(y - p.y, 2);
                const sim = Math.exp(-gamma * d);
                if (p.class === 1) redSum += sim;
                else blueSum += sim;
              });
              const total = redSum + blueSum;
              if (total === 0) return null;
              const redProb = redSum / total;
              return redProb - 0.5;
            };

            // ë¶€ë“œëŸ¬ìš´ ê·¸ë¼ë°ì´ì…˜ ë Œë”ë§
            for (let x = PADDING; x < WIDTH - PADDING; x += 3) {
              for (let y = PADDING; y < HEIGHT - PADDING; y += 3) {
                const val = predictPoint(x, y);
                if (val === null) continue;
                
                // ê²°ì • ê²½ê³„ë¡œë¶€í„°ì˜ ê±°ë¦¬ì— ë”°ë¥¸ ì•ŒíŒŒê°’
                // ê²½ê³„(val=0)ì—ì„œ ê°€ê¹Œìš°ë©´ ì—°í•˜ê³ , ë©€ë©´ ì§„í•˜ê²Œ
                const boundaryDist = Math.abs(val);
                
                // ê°€ì¥ ê°€ê¹Œìš´ ë°ì´í„° í¬ì¸íŠ¸ê¹Œì§€ì˜ ì‹¤ì œ ê±°ë¦¬
                let minDist = Infinity;
                svmPoints.forEach(p => {
                  const d = Math.sqrt(Math.pow(x - p.x, 2) + Math.pow(y - p.y, 2));
                  minDist = Math.min(minDist, d);
                });
                
                // ê±°ë¦¬ì— ë”°ë¥¸ ê°ì‡  ê³„ì‚° (ë°ì´í„° í¬ì¸íŠ¸ì—ì„œ ë©€ìˆ˜ë¡ ì—°í•´ì§)
                const distanceDecay = Math.exp(-minDist / 80);
                
                // ê²½ê³„ë¡œë¶€í„°ì˜ ê±°ë¦¬ì™€ ì‹¤ì œ ê±°ë¦¬ë¥¼ ëª¨ë‘ ê³ ë ¤
                const alpha = Math.min(0.7, 
                  0.05 + // ê¸°ë³¸ íˆ¬ëª…ë„
                  boundaryDist * 0.4 + // ê²½ê³„ì—ì„œ ë©€ìˆ˜ë¡ ì§„í•˜ê²Œ
                  distanceDecay * 0.5 // ë°ì´í„° í¬ì¸íŠ¸ ê·¼ì²˜ì—ì„œ ì§„í•˜ê²Œ
                );
                
                ctx.fillStyle = val > 0 
                  ? `rgba(239, 68, 68, ${alpha})`
                  : `rgba(59, 130, 246, ${alpha})`;
                ctx.fillRect(x, y, 3, 3);
              }
            }

            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            for (let x = PADDING; x < WIDTH - PADDING - 4; x += 4) {
              for (let y = PADDING; y < HEIGHT - PADDING - 4; y += 4) {
                const v = [];
                let hasValue = false;
                
                // 4ê°œì˜ ì½”ë„ˆ ê°’ ê³„ì‚°
                for (let dx = 0; dx <= 4; dx += 4) {
                  for (let dy = 0; dy <= 4; dy += 4) {
                    const val = predictPoint(x + dx, y + dy);
                    v.push(val !== null ? val : 0);
                    if (val !== null) hasValue = true;
                  }
                }
                
                if (!hasValue) continue;
                
                // ë¶€í˜¸ ë³€í™”ê°€ ìˆëŠ” ê³³ì— ê²½ê³„ì„  ê·¸ë¦¬ê¸°
                const s = v.map(val => val >= 0 ? 1 : 0);
                const cfg = s[0] * 8 + s[1] * 4 + s[2] * 2 + s[3];
                
                // ê²½ê³„ì„ ì´ ì§€ë‚˜ê°€ëŠ” ëª¨ë“  ê²½ìš° ì²˜ë¦¬
                if (cfg !== 0 && cfg !== 15) {
                  ctx.beginPath();
                  
                  if (cfg === 1 || cfg === 14) {
                    const t1 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[1]) + 0.001);
                    const t2 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3]) + 0.001);
                    ctx.moveTo(x + 4 * t1, y);
                    ctx.lineTo(x, y + 4 * t2);
                  } else if (cfg === 2 || cfg === 13) {
                    const t1 = Math.abs(v[2]) / (Math.abs(v[2]) + Math.abs(v[3]) + 0.001);
                    const t2 = Math.abs(v[2]) / (Math.abs(v[2]) + Math.abs(v[1]) + 0.001);
                    ctx.moveTo(x + 4 * t1, y + 4);
                    ctx.lineTo(x + 4, y + 4 * t2);
                  } else if (cfg === 3 || cfg === 12) {
                    const t1 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[3]) + 0.001);
                    const t2 = Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[2]) + 0.001);
                    ctx.moveTo(x, y + 4 * t1);
                    ctx.lineTo(x + 4, y + 4 * t2);
                  } else if (cfg === 4 || cfg === 11) {
                    const t1 = Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[0]) + 0.001);
                    const t2 = Math.abs(v[1]) / (Math.abs(v[1]) + Math.abs(v[2]) + 0.001);
                    ctx.moveTo(x + 4 * t1, y);
                    ctx.lineTo(x + 4, y + 4 * t2);
                  } else if (cfg === 6 || cfg === 9) {
                    const t1 = Math.abs(v[0]) / (Math.abs(v[0]) + Math.abs(v[1]) + 0.001);
                    const t2 = Math.abs(v[3]) / (Math.abs(v[3]) + Math.abs(v[2]) + 0.001);
                    ctx.moveTo(x + 4 * t1, y);
                    ctx.lineTo(x + 4 * t2, y + 4);
                  } else if (cfg === 7 || cfg === 8) {
                    const t1 = Math.abs(v[3]) / (Math.abs(v[3]) + Math.abs(v[0]) + 0.001);
                    const t2 = Math.abs(v[3]) / (Math.abs(v[3]) + Math.abs(v[2]) + 0.001);
                    ctx.moveTo(x, y + 4 * t1);
                    ctx.lineTo(x + 4 * t2, y + 4);
                  }
                  
                  ctx.stroke();
                }
              }
            }
          }
        }

        points.forEach(point => {
          const isSV = svm?.supportVectors?.some(sv => Math.abs(sv.x - point.x) < 1 && Math.abs(sv.y - point.y) < 1);
          ctx.beginPath();
          ctx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
          ctx.fillStyle = point.class === 1 ? '#ef4444' : '#3b82f6';
          ctx.fill();
          ctx.strokeStyle = point.class === 1 ? '#991b1b' : '#1e40af';
          ctx.lineWidth = 2;
          ctx.stroke();
          if (isSV) {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 14, 0, 2 * Math.PI);
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 3;
            ctx.stroke();
          }
        });
      }, [points, svm, kernelMode, polynomialDegree, rbfGamma]);

      const handleClick = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const scaleX = WIDTH / rect.width;
        const scaleY = HEIGHT / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        if (x >= PADDING && x <= WIDTH - PADDING && y >= PADDING && y <= HEIGHT - PADDING) {
          setPoints([...points, { x, y, class: selectedClass }]);
          setSvm(null);
        }
      };

      const handleMouseMove = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const scaleX = WIDTH / rect.width;
        const scaleY = HEIGHT / rect.height;
        const mx = (e.clientX - rect.left) * scaleX;
        const my = (e.clientY - rect.top) * scaleY;

        let found = null;
        for (let p of points) {
          if (Math.hypot(mx - p.x, my - p.y) <= 12) {
            found = p;
            break;
          }
        }
        setHovered(found);
      };

      const reset = () => {
        setPoints(generateInitialData());
        setSvm(null);
        setSelectedClass(1);
      };

      const redCount = points.filter(p => p.class === 1).length;
      const blueCount = points.filter(p => p.class === -1).length;

      return (
        <div className="max-w-6xl mx-auto bg-white rounded-2xl shadow-2xl overflow-hidden">
          <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white">
            <div className="text-sm mb-2 text-indigo-100">ë¶€ì‚°ì§„ì—¬ììƒì—…ê³ ë“±í•™êµ ì¸ê³µì§€ëŠ¥ê¸°ì´ˆ í•™ìŠµìë£Œ</div>
            <h1 className="text-3xl font-bold mb-2">ì„œí¬íŠ¸ ë²¡í„° ë¨¸ì‹ (SVM)ì´ë€ ë¬´ì—‡ì¼ê¹Œ?</h1>
            <p className="text-indigo-100">ìµœì ì˜ ê²½ê³„ì„ ì„ ì°¾ì•„ ë°ì´í„°ë¥¼ ë¶„ë¥˜í•˜ëŠ” ê°•ë ¥í•œ AI ì•Œê³ ë¦¬ì¦˜ì„ ì²´í—˜í•´ë³´ì„¸ìš”</p>
          </div>

          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 border-b border-indigo-100">
            <div className="space-y-3 text-gray-700">
              <div>
                <h3 className="font-bold text-indigo-900 text-lg mb-2">ğŸ“š SVM ì•Œê³ ë¦¬ì¦˜ì´ë€?</h3>
                <p className="leading-relaxed">
                  SVMì€ ë‘ ê·¸ë£¹ì„ <span className="font-bold text-blue-600">ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ëœ¨ë¦¬ëŠ” ê²½ê³„ì„ </span>ì„ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ì—ìš”. 
                  ì˜ˆë¥¼ ë“¤ì–´, ì¶•êµ¬ë¥¼ ì¢‹ì•„í•˜ëŠ” í•™ìƒë“¤ê³¼ ë†êµ¬ë¥¼ ì¢‹ì•„í•˜ëŠ” í•™ìƒë“¤ì„ ë‚˜ëˆŒ ë•Œ, 
                  ì–‘ìª½ ê·¸ë£¹ì—ì„œ <span className="font-bold text-yellow-600">ê°€ì¥ ê°€ê¹Œìš´ í•™ìƒë“¤(ì„œí¬íŠ¸ ë²¡í„°)</span>ê³¼ì˜ ê±°ë¦¬ê°€ 
                  <span className="font-bold text-green-600">ìµœëŒ€í•œ ë©€ì–´ì§€ëŠ” ì¤‘ê°„ì„ </span>ì„ ì°¾ëŠ” ê²ƒê³¼ ê°™ì•„ìš”!
                </p>
              </div>
              
              <div className="grid md:grid-cols-3 gap-4 mt-4">
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-indigo-700 mb-2">1ï¸âƒ£ ë°ì´í„° ì¶”ê°€</h4>
                  <p className="text-sm">í´ë˜ìŠ¤ A ë˜ëŠ” í´ë˜ìŠ¤ B ë²„íŠ¼ì„ ì„ íƒí•œ í›„ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì—¬ í•™ìŠµ ë°ì´í„°ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-green-700 mb-2">2ï¸âƒ£ ì»¤ë„ ì„ íƒ</h4>
                  <p className="text-sm">ì§ì„ , ë‹¤í•­ì‹, RBF ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì—¬ ë‹¤ì–‘í•œ í˜•íƒœì˜ ê²½ê³„ì„ ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-purple-700 mb-2">3ï¸âƒ£ í•™ìŠµ ì‹¤í–‰</h4>
                  <p className="text-sm">'í•™ìŠµ ì‹œì‘!' ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ AIê°€ ìµœì ì˜ ê²°ì • ê²½ê³„ì™€ ì„œí¬íŠ¸ ë²¡í„°ë¥¼ ì°¾ì•„ëƒ…ë‹ˆë‹¤.</p>
                </div>
              </div>
            </div>
          </div>

          <div className="p-6">
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
              <div className="space-y-4">
                <div className="bg-indigo-50 p-4 rounded-lg border border-indigo-200">
                  <h3 className="font-bold text-indigo-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">âš™ï¸</span>
                    <span>ì»¤ë„ ì„¤ì •</span>
                  </h3>
                  
                  <div className="space-y-2">
                    <button onClick={() => { setKernelMode('linear'); setSvm(null); }}
                      className={`w-full py-2 px-3 rounded-lg font-medium transition-all ${kernelMode === 'linear' ? 'bg-purple-500 text-white shadow-md' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}`}>
                      ì§ì„  ì»¤ë„
                    </button>
                    <button onClick={() => { setKernelMode('polynomial'); setSvm(null); }}
                      className={`w-full py-2 px-3 rounded-lg font-medium transition-all ${kernelMode === 'polynomial' ? 'bg-purple-500 text-white shadow-md' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}`}>
                      ë‹¤í•­ì‹ ì»¤ë„
                    </button>
                    <button onClick={() => { setKernelMode('rbf'); setSvm(null); }}
                      className={`w-full py-2 px-3 rounded-lg font-medium transition-all ${kernelMode === 'rbf' ? 'bg-purple-500 text-white shadow-md' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'}`}>
                      RBF ì»¤ë„
                    </button>
                  </div>

                  {kernelMode === 'polynomial' && (
                    <div className="mt-3">
                      <label className="text-sm text-gray-600 block mb-1">ì°¨ìˆ˜: {polynomialDegree}</label>
                      <input type="range" min="2" max="3" value={polynomialDegree} 
                        onChange={(e) => { setPolynomialDegree(parseInt(e.target.value)); setSvm(null); }} 
                        className="w-full" />
                      <p className="text-xs text-gray-500 mt-1">*ì°¨ìˆ˜ê°€ ë†’ì„ìˆ˜ë¡ ë³µì¡í•œ ê³¡ì„  ê°€ëŠ¥</p>
                    </div>
                  )}
                  {kernelMode === 'rbf' && (
                    <div className="mt-3">
                      <label className="text-sm text-gray-600 block mb-1">Î³ (ê°ë§ˆ): {rbfGamma.toFixed(2)}</label>
                      <input type="range" min="0.1" max="2" step="0.1" value={rbfGamma} 
                        onChange={(e) => { setRbfGamma(parseFloat(e.target.value)); setSvm(null); }} 
                        className="w-full" />
                      <p className="text-xs text-gray-500 mt-1">*ê°’ì´ í´ìˆ˜ë¡ ê²½ê³„ê°€ ë³µì¡í•´ì§</p>
                    </div>
                  )}
                </div>

                <div className="bg-green-50 p-4 rounded-lg border border-green-200">
                  <h3 className="font-bold text-green-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ“Š</span>
                    <span>ë°ì´í„° ì…ë ¥</span>
                  </h3>
                  <div className="space-y-2">
                    <button onClick={() => setSelectedClass(1)}
                      className={`w-full p-3 rounded-lg font-semibold transition-all ${selectedClass === 1 ? 'bg-red-500 text-white shadow-lg scale-105' : 'bg-white text-red-600 border-2 border-red-300 hover:bg-red-50'}`}>
                      í´ë˜ìŠ¤ A ì¶”ê°€
                    </button>
                    <button onClick={() => setSelectedClass(-1)}
                      className={`w-full p-3 rounded-lg font-semibold transition-all ${selectedClass === -1 ? 'bg-blue-500 text-white shadow-lg scale-105' : 'bg-white text-blue-600 border-2 border-blue-300 hover:bg-blue-50'}`}>
                      í´ë˜ìŠ¤ B ì¶”ê°€
                    </button>
                  </div>
                </div>

                <div className="bg-orange-50 p-4 rounded-lg border border-orange-200">
                  <h3 className="font-bold text-orange-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ®</span>
                    <span>ë™ì‘</span>
                  </h3>
                  <div className="space-y-2">
                    <button onClick={handleTrain} disabled={points.length < 2}
                      className="w-full bg-green-500 text-white py-3 rounded-lg font-semibold hover:bg-green-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-all">
                      í•™ìŠµ ì‹œì‘!
                    </button>
                    <button onClick={() => { setPoints([]); setSvm(null); }}
                      className="w-full bg-orange-500 text-white py-3 rounded-lg font-semibold hover:bg-orange-600 transition-all">
                      ëª¨ë‘ ì§€ìš°ê¸°
                    </button>
                    <button onClick={reset}
                      className="w-full bg-gray-500 text-white py-3 rounded-lg font-semibold hover:bg-gray-600 transition-all">
                      ì´ˆê¸°í™”
                    </button>
                  </div>
                </div>

                <div className="bg-pink-50 p-4 rounded-lg border border-pink-200">
                  <h3 className="font-bold text-pink-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ“ˆ</span>
                    <span>ë°ì´í„° í˜„í™©</span>
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">í´ë˜ìŠ¤ A:</span>
                      <span className="font-bold text-red-600">{redCount}ê°œ</span>
                    </div>
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">í´ë˜ìŠ¤ B:</span>
                      <span className="font-bold text-blue-600">{blueCount}ê°œ</span>
                    </div>
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">ì „ì²´:</span>
                      <span className="font-bold">{points.length}ê°œ</span>
                    </div>
                    {svm && svm.supportVectors && (
                      <div className="flex justify-between items-center p-2 bg-yellow-100 rounded">
                        <span className="font-medium">ì„œí¬íŠ¸ ë²¡í„°:</span>
                        <span className="font-bold text-yellow-700">{svm.supportVectors.length}ê°œ</span>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              <div className="lg:col-span-3 space-y-4">
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                  <h3 className="font-bold text-gray-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ¯</span>
                    <span>2ì°¨ì› íŠ¹ì„± ê³µê°„</span>
                  </h3>
                  <div className="relative bg-white rounded-lg shadow-inner overflow-hidden border-2 border-gray-300">
                    <canvas ref={canvasRef} width={WIDTH} height={HEIGHT} 
                      onClick={handleClick} onMouseMove={handleMouseMove} 
                      onMouseLeave={() => setHovered(null)}
                      className="block w-full cursor-crosshair" />
                    {hovered && (
                      <div className="absolute bg-gray-900 text-white text-xs px-3 py-1 rounded-md pointer-events-none shadow-lg"
                        style={{ left: hovered.x + 15, top: hovered.y - 10 }}>
                        {hovered.class === 1 ? 'í´ë˜ìŠ¤ A' : 'í´ë˜ìŠ¤ B'}
                      </div>
                    )}
                  </div>

                  {svm && (
                    <div className="mt-4 bg-gradient-to-r from-green-50 to-emerald-50 p-5 rounded-lg border-2 border-green-400">
                      <h3 className="text-xl font-bold text-green-800 mb-3 flex items-center gap-2">
                        <span>âœ…</span>
                        <span>í•™ìŠµ ì™„ë£Œ!</span>
                      </h3>
                      <div className="space-y-3">
                        <div className="bg-white p-4 rounded-lg shadow-sm">
                          <p className="font-semibold text-gray-800 mb-2">
                            ğŸ” {kernelMode === 'linear' ? 'ì§ì„  ì»¤ë„' : kernelMode === 'polynomial' ? `ë‹¤í•­ì‹ ì»¤ë„ (${polynomialDegree}ì°¨)` : `RBF ì»¤ë„ (Î³=${rbfGamma.toFixed(2)})`}
                          </p>
                          <div className="space-y-2 text-sm text-gray-700">
                            {kernelMode === 'linear' && (
                              <>
                                <p>â€¢ <span className="font-semibold text-blue-600">íŒŒë€ ì‹¤ì„ </span>: ë‘ í´ë˜ìŠ¤ë¥¼ ë‚˜ëˆ„ëŠ” ê²°ì • ê²½ê³„</p>
                                <p>â€¢ <span className="font-semibold text-blue-400">íŒŒë€ ì ì„ </span>: ë§ˆì§„ ê²½ê³„ (ì„œí¬íŠ¸ ë²¡í„°ì™€ì˜ ê±°ë¦¬)</p>
                                <p>â€¢ ë‘ ì ì„  ì‚¬ì´ì˜ ê±°ë¦¬ê°€ <span className="font-bold text-green-600">ë§ˆì§„</span>ì…ë‹ˆë‹¤</p>
                              </>
                            )}
                            {kernelMode === 'polynomial' && (
                              <>
                                <p>â€¢ <span className="font-semibold text-blue-600">íŒŒë€ ê³¡ì„ </span>: ê³¡ì„  í˜•íƒœì˜ ê²°ì • ê²½ê³„</p>
                                <p>â€¢ íƒ€ì›, í¬ë¬¼ì„  ë“± ë³µì¡í•œ íŒ¨í„´ ë¶„ë¥˜ ê°€ëŠ¥</p>
                                <p>â€¢ ë°°ê²½ìƒ‰ìœ¼ë¡œ ê° ì˜ì—­ì˜ ì†Œì† í´ë˜ìŠ¤ í‘œì‹œ</p>
                              </>
                            )}
                            {kernelMode === 'rbf' && (
                              <>
                                <p>â€¢ <span className="font-semibold text-blue-600">íŒŒë€ ê³¡ì„ </span>: ììœ ë¡œìš´ í˜•íƒœì˜ ê²°ì • ê²½ê³„</p>
                                <p>â€¢ ì ì—ì„œ ë©€ì–´ì§ˆìˆ˜ë¡ ìƒ‰ì´ ì—°í•´ì§€ëŠ” ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼</p>
                                <p>â€¢ ê°€ì¥ ë³µì¡í•œ íŒ¨í„´ë„ ë¶„ë¥˜ ê°€ëŠ¥!</p>
                              </>
                            )}
                            <p className="mt-2 pt-2 border-t border-gray-200">
                              â€¢ <span className="inline-block w-3 h-3 rounded-full border-2 border-yellow-500 mr-1"></span>
                              <span className="font-semibold text-yellow-600">ë…¸ë€ í…Œë‘ë¦¬</span>: 
                              ê²°ì • ê²½ê³„ì— ê°€ì¥ ê°€ê¹Œìš´ ì¤‘ìš”í•œ ì ë“¤ (ì„œí¬íŠ¸ ë²¡í„°)
                            </p>
                          </div>
                        </div>

                        <div className="bg-indigo-50 p-4 rounded-lg">
                          <p className="text-sm font-semibold text-indigo-900 mb-2">ğŸ’¡ SVMì˜ í•µì‹¬ ì•„ì´ë””ì–´</p>
                          <p className="text-sm text-gray-700 leading-relaxed">
                            SVMì€ ë‹¨ìˆœíˆ ê²½ê³„ì„ ì„ ê·¸ë¦¬ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, <span className="font-bold text-purple-600">ì–‘ìª½ í´ë˜ìŠ¤ì™€ ìµœëŒ€í•œ ë©€ë¦¬ ë–¨ì–´ì§„ ê²½ê³„ì„ </span>ì„ ì°¾ìŠµë‹ˆë‹¤. 
                            ì´ë ‡ê²Œ í•˜ë©´ ìƒˆë¡œìš´ ë°ì´í„°ê°€ ë“¤ì–´ì™”ì„ ë•Œë„ ì •í™•í•˜ê²Œ ë¶„ë¥˜í•  ìˆ˜ ìˆì–´ìš”! 
                            <span className="font-bold text-yellow-600">ì„œí¬íŠ¸ ë²¡í„°</span>ëŠ” ì´ ê²½ê³„ì„ ì„ ê²°ì •í•˜ëŠ” ë° ê°€ì¥ ì¤‘ìš”í•œ ì—­í• ì„ í•˜ëŠ” ì ë“¤ì…ë‹ˆë‹¤.
                          </p>
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                <div className="flex justify-center gap-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
                  <div className="flex items-center gap-2">
                    <div className="w-5 h-5 bg-red-500 rounded-full border-2 border-gray-800"></div>
                    <span className="font-medium text-gray-700">í´ë˜ìŠ¤ A (ì¶•êµ¬ë°˜)</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-5 h-5 bg-blue-500 rounded-full border-2 border-gray-800"></div>
                    <span className="font-medium text-gray-700">í´ë˜ìŠ¤ B (ë†êµ¬ë°˜)</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-5 h-5 bg-white rounded-full border-4 border-yellow-500"></div>
                    <span className="font-medium text-gray-700">ì„œí¬íŠ¸ ë²¡í„°</span>
                  </div>
                </div>

                <div className="bg-gradient-to-r from-purple-50 to-pink-50 p-5 rounded-lg border border-purple-200">
                  <h3 className="text-lg font-bold text-purple-900 mb-3">ğŸ§  ì»¤ë„ì˜ ì¢…ë¥˜ ì´í•´í•˜ê¸°</h3>
                  <div className="grid md:grid-cols-3 gap-4">
                    <div className="bg-white p-4 rounded-lg shadow-sm">
                      <h4 className="font-bold text-purple-600 mb-2">ì§ì„  ì»¤ë„ ğŸ“</h4>
                      <p className="text-sm text-gray-700">
                        ê°€ì¥ ë‹¨ìˆœí•œ í˜•íƒœì˜ˆìš”. ë°ì´í„°ë¥¼ ì§ì„ ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆì„ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. 
                        ë¹ ë¥´ê³  ê°„ë‹¨í•˜ì§€ë§Œ, ë³µì¡í•œ íŒ¨í„´ì€ ë¶„ë¥˜í•˜ê¸° ì–´ë ¤ì›Œìš”.
                      </p>
                    </div>
                    <div className="bg-white p-4 rounded-lg shadow-sm">
                      <h4 className="font-bold text-purple-600 mb-2">ë‹¤í•­ì‹ ì»¤ë„ ğŸ“</h4>
                      <p className="text-sm text-gray-700">
                        ê³¡ì„ ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë‚˜ëˆŒ ìˆ˜ ìˆì–´ìš”. íƒ€ì›ì´ë‚˜ í¬ë¬¼ì„  ê°™ì€ ëª¨ì–‘ìœ¼ë¡œ 
                        ê²½ê³„ë¥¼ ë§Œë“¤ ìˆ˜ ìˆì–´ì„œ ì¡°ê¸ˆ ë” ë³µì¡í•œ íŒ¨í„´ì„ ë¶„ë¥˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                      </p>
                    </div>
                    <div className="bg-white p-4 rounded-lg shadow-sm">
                      <h4 className="font-bold text-purple-600 mb-2">RBF ì»¤ë„ ğŸ¨</h4>
                      <p className="text-sm text-gray-700">
                        ê°€ì¥ ìœ ì—°í•œ í˜•íƒœì˜ˆìš”! ì ì—ì„œ ê°€ê¹Œìš¸ìˆ˜ë¡ ì˜í–¥ì´ í¬ê³ , ë©€ìˆ˜ë¡ 
                        ì˜í–¥ì´ ì‘ì•„ì§€ëŠ” ì›ë¦¬ë¡œ ì•„ì£¼ ë³µì¡í•œ íŒ¨í„´ë„ ë¶„ë¥˜í•  ìˆ˜ ìˆì–´ìš”.
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SVMDemo />);
  </script>
</body>
</html>